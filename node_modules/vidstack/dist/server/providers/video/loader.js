import { $$_ssr, $$_attr } from 'maverick.js/ssr';
import { computed } from 'maverick.js';
import { isString } from 'maverick.js/std';
import { V as VIDEO_EXTENSIONS, b as VIDEO_TYPES, i as isHLSSrc } from '../audio/loader.js';

const $$_templ = ["<!$><video", "", "", "", "", "", ' preload="none" aria-hidden="true"></video>'];
class VideoProviderLoader {
  canPlay(src) {
    return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && true : src.type === "video/object";
  }
  mediaType() {
    return "video";
  }
  async load(context) {
    if (!this._video) {
      throw Error(
        "[vidstack] `<video>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./provider.js')).VideoProvider(this._video, context);
  }
  render($store) {
    const $poster = computed(() => $store.poster() && $store.controls() ? $store.poster() : null);
    {
      const src = $store.source().src;
      return $$_ssr(
        $$_templ,
        $$_attr("src", isString(src) ? src : null),
        $$_attr("poster", $poster),
        $$_attr("muted", $store.muted),
        $$_attr("controls", $store.controls),
        $$_attr("crossorigin", $store.crossorigin),
        $$_attr("playsinline", $store.playsinline)
      );
    }
  }
}

export { VideoProviderLoader as V };
