import { effect, onDispose } from 'maverick.js';
import { useDisposalBin, listenEvent, DOMEvent, isNil } from 'maverick.js/std';
import { R as RAFLoop } from '../hls/hls.js';
import { i as isHLSSrc } from '../audio/loader.js';
import { y as getNumberOfDecimalPlaces } from '../../media-ui.js';
import { I as IS_SAFARI } from '../../media-core.js';

class HTMLMediaEvents {
  constructor(_provider, _context) {
    this.m = _provider;
    this.ph = _context;
    this.ai();
    effect(this.bi.bind(this));
    onDispose(this.qh.bind(this));
  }
  ih = useDisposalBin();
  Vh = false;
  Yh = false;
  Zh = false;
  Wh = new RAFLoop(this.ci.bind(this));
  get n() {
    return this.m.media;
  }
  get jg() {
    return this.ph.delegate;
  }
  qh() {
    this.Wh.N();
    this.ih.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  ci() {
    const newTime = this.m.currentTime;
    if (this.ph.$store.currentTime() !== newTime)
      this.Uh(newTime);
  }
  ai() {
    this.Th("loadstart", this.je);
    this.Th("abort", this._h);
    this.Th("emptied", this.di);
    this.Th("error", this.Zb);
  }
  ei() {
    if (this.Yh)
      return;
    this.ih.add(
      this.Th("loadeddata", this.fi),
      this.Th("loadedmetadata", this.gi),
      this.Th("canplay", this.Ub),
      this.Th("canplaythrough", this.hi),
      this.Th("durationchange", this.ii),
      this.Th("play", this.ji),
      this.Th("progress", this.ki),
      this.Th("stalled", this.li),
      this.Th("suspend", this.mi)
    );
    this.Yh = true;
  }
  ni() {
    if (this.Zh)
      return;
    this.ih.add(
      this.Th("pause", this.oi),
      this.Th("playing", this.pi),
      this.Th("ratechange", this.qi),
      this.Th("seeked", this.ri),
      this.Th("seeking", this.si),
      this.Th("ended", this.ti),
      this.Th("volumechange", this.dc),
      this.Th("waiting", this.ui)
    );
    this.Zh = true;
  }
  vi = void 0;
  xi = void 0;
  Th(eventType, handler) {
    return listenEvent(
      this.n,
      eventType,
      handler.bind(this)
    );
  }
  yi(event2) {
    return;
  }
  Uh(time, trigger) {
    this.jg.U("time-update", {
      // Avoid errors where `currentTime` can have higher precision.
      detail: {
        currentTime: Math.min(time, this.ph.$store.seekableEnd()),
        played: this.n.played
      },
      trigger
    });
  }
  je(event2) {
    if (this.n.networkState === 3) {
      this._h(event2);
      return;
    }
    this.ei();
    this.jg.U("load-start", { trigger: event2 });
  }
  _h(event2) {
    this.jg.U("abort", { trigger: event2 });
  }
  di() {
    this.jg.U("emptied", { trigger: event });
  }
  fi(event2) {
    this.jg.U("loaded-data", { trigger: event2 });
  }
  gi(event2) {
    this.$h();
    this.ni();
    this.jg.U("volume-change", {
      detail: {
        volume: this.n.volume,
        muted: this.n.muted
      }
    });
    this.jg.U("loaded-metadata", { trigger: event2 });
    if (IS_SAFARI && isHLSSrc(this.ph.$store.source())) {
      this.jg.af(this.Xh(), event2);
    }
  }
  Xh() {
    return {
      duration: this.n.duration,
      buffered: this.n.buffered,
      seekable: this.n.seekable
    };
  }
  $h() {
    const isLive = !Number.isFinite(this.n.duration);
    this.jg.U("stream-type-change", {
      detail: isLive ? "live" : "on-demand"
    });
  }
  ji(event2) {
    if (!this.ph.$store.canPlay)
      return;
    this.jg.U("play", { trigger: event2 });
  }
  oi(event2) {
    if (this.n.readyState === 1 && !this.Vh)
      return;
    this.Vh = false;
    this.Wh.N();
    this.jg.U("pause", { trigger: event2 });
  }
  Ub(event2) {
    this.jg.af(this.Xh(), event2);
  }
  hi(event2) {
    if (this.ph.$store.started())
      return;
    this.jg.U("can-play-through", {
      trigger: event2,
      detail: this.Xh()
    });
  }
  pi(event2) {
    this.Vh = false;
    this.jg.U("playing", { trigger: event2 });
    this.Wh.M();
  }
  li(event2) {
    this.jg.U("stalled", { trigger: event2 });
    if (this.n.readyState < 3) {
      this.Vh = true;
      this.jg.U("waiting", { trigger: event2 });
    }
  }
  ui(event2) {
    if (this.n.readyState < 3) {
      this.Vh = true;
      this.jg.U("waiting", { trigger: event2 });
    }
  }
  ti(event2) {
    this.Wh.N();
    this.Uh(this.n.duration, event2);
    this.jg.U("end", { trigger: event2 });
    if (this.ph.$store.loop()) {
      this.wi();
    } else {
      this.jg.U("ended", { trigger: event2 });
    }
  }
  bi() {
    if (this.ph.$store.paused()) {
      listenEvent(this.n, "timeupdate", this.Yb.bind(this));
    }
  }
  Yb(event2) {
    this.Uh(this.n.currentTime, event2);
  }
  ii(event2) {
    this.$h();
    if (this.ph.$store.ended()) {
      this.Uh(this.n.duration, event2);
    }
    this.jg.U("duration-change", {
      detail: this.n.duration,
      trigger: event2
    });
  }
  dc(event2) {
    this.jg.U("volume-change", {
      detail: {
        volume: this.n.volume,
        muted: this.n.muted
      },
      trigger: event2
    });
  }
  ri(event2) {
    this.Uh(this.n.currentTime, event2);
    this.jg.U("seeked", {
      detail: this.n.currentTime,
      trigger: event2
    });
    if (Math.trunc(this.n.currentTime) === Math.trunc(this.n.duration) && getNumberOfDecimalPlaces(this.n.duration) > getNumberOfDecimalPlaces(this.n.currentTime)) {
      this.Uh(this.n.duration, event2);
      if (!this.n.ended) {
        this.ph.player.dispatchEvent(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  si(event2) {
    this.jg.U("seeking", {
      detail: this.n.currentTime,
      trigger: event2
    });
  }
  ki(event2) {
    this.jg.U("progress", {
      detail: {
        buffered: this.n.buffered,
        seekable: this.n.seekable
      },
      trigger: event2
    });
  }
  wi() {
    const hasCustomControls = isNil(this.n.controls);
    if (hasCustomControls)
      this.n.controls = false;
    this.ph.player.dispatchEvent(new DOMEvent("media-loop-request"));
  }
  mi(event2) {
    this.jg.U("suspend", { trigger: event2 });
  }
  qi(event2) {
    this.jg.U("rate-change", {
      detail: this.n.playbackRate,
      trigger: event2
    });
  }
  Zb(event2) {
    const error = this.n.error;
    if (!error)
      return;
    this.jg.U("error", {
      detail: {
        message: error.message,
        code: error.code,
        mediaError: error
      },
      trigger: event2
    });
  }
}

export { HTMLMediaEvents as H };
