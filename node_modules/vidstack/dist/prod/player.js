import { deferredPromise, listenEvent, setAttribute, uppercaseFirstChar, camelToKebabCase } from 'maverick.js/std';
import { Component, defineElement, prop, method } from 'maverick.js/element';
import { getScope, signal, computed, provideContext, effect, peek } from 'maverick.js';
import { m as mediaPlayerProps, M as MediaStoreFactory, j as MediaStoreSync, V as VideoQualityList, k as AudioTrackList, T as TextTrackList, l as TEXT_TRACK_CROSSORIGIN, n as TextRenderers, q as mediaContext, S as ScreenOrientationController, r as MediaKeyboardController, t as ThumbnailsLoader, v as MediaStateManager, w as MediaRequestManager, x as MediaPlayerDelegate, y as MediaLoadController, a as setAttributeIfEmpty, z as IS_IPHONE, i as isTrackCaptionKind, B as MEDIA_ATTRIBUTES, C as canFullscreen, D as MediaRemoteControl, E as MediaRequestContext } from './media-core.js';
import { w as FocusVisibleController, x as clampNumber } from './media-ui.js';

class RequestQueue {
  Qe = false;
  Re = deferredPromise();
  Pe = /* @__PURE__ */ new Map();
  /**
   * The number of callbacks that are currently in queue.
   */
  get Ve() {
    return this.Pe.size;
  }
  /**
   * Whether items in the queue are being served immediately, otherwise they're queued to
   * be processed later.
   */
  get We() {
    return this.Qe;
  }
  /**
   * Waits for the queue to be flushed (ie: start serving).
   */
  async Xe() {
    if (this.Qe)
      return;
    await this.Re.promise;
  }
  /**
   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
   * then the callback will be invoked immediately.
   *
   * @param key - Uniquely identifies this callback so duplicates are ignored.
   * @param callback - The function to call when this item in the queue is being served.
   */
  q(key, callback) {
    if (this.Qe) {
      callback();
      return;
    }
    this.Pe.delete(key);
    this.Pe.set(key, callback);
  }
  /**
   * Invokes the callback with the given `key` in the queue (if it exists).
   */
  Ue(key) {
    this.Pe.get(key)?.();
    this.Pe.delete(key);
  }
  /**
   * Flush all queued items and start serving future requests immediately until `stop()` is called.
   */
  M() {
    this.Se();
    this.Qe = true;
    if (this.Pe.size > 0)
      this.Se();
  }
  /**
   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
   */
  N() {
    this.Qe = false;
  }
  /**
   * Stop serving requests, empty the request queue, and release any promises waiting for the
   * queue to flush.
   */
  Ye() {
    this.N();
    this.Pe.clear();
    this.Te();
  }
  Se() {
    for (const key of this.Pe.keys())
      this.Ue(key);
    this.Te();
  }
  Te() {
    this.Re.resolve();
    this.Re = deferredPromise();
  }
}

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
class Player extends Component {
  static el = defineElement({
    tagName: "media-player",
    props: mediaPlayerProps,
    store: MediaStoreFactory
  });
  n;
  r;
  o;
  p = new RequestQueue();
  get m() {
    return this.n.$provider();
  }
  constructor(instance) {
    super(instance);
    this.u();
    new MediaStoreSync(instance);
    const context = {
      player: null,
      scope: getScope(),
      qualities: new VideoQualityList(),
      audioTracks: new AudioTrackList(),
      $provider: signal(null),
      $props: this.$props,
      $store: this.$store
    };
    context.remote = new MediaRemoteControl(void 0);
    context.$iosControls = computed(this.v.bind(this));
    context.textTracks = new TextTrackList();
    context.textTracks[TEXT_TRACK_CROSSORIGIN] = this.$props.crossorigin;
    context.textRenderers = new TextRenderers(context);
    context.ariaKeys = {};
    this.n = context;
    provideContext(mediaContext, context);
    this.orientation = new ScreenOrientationController(instance);
    new FocusVisibleController(instance);
    new MediaKeyboardController(instance, context);
    new ThumbnailsLoader(instance);
    const request = new MediaRequestContext();
    this.r = new MediaStateManager(instance, request, context);
    this.o = new MediaRequestManager(instance, this.r, request, context);
    context.delegate = new MediaPlayerDelegate(
      this.r.L.bind(this.r),
      context
    );
    new MediaLoadController(instance, this.startLoading.bind(this));
  }
  onAttach(el) {
    el.setAttribute("tabindex", "0");
    setAttributeIfEmpty(el, "role", "region");
    effect(this.w.bind(this));
    effect(this.x.bind(this));
    effect(this.y.bind(this));
    effect(this.z.bind(this));
    effect(this.A.bind(this));
    effect(this.B.bind(this));
    effect(this.C.bind(this));
    effect(this.D.bind(this));
    effect(this.E.bind(this));
    this.F();
    this.G();
    this.n.player = el;
    this.n.remote.setTarget(el);
    this.n.remote.setPlayer(el);
    listenEvent(el, "find-media-player", this.H.bind(this));
  }
  onConnect(el) {
    if (IS_IPHONE)
      setAttribute(el, "data-iphone", "");
    const pointerQuery = window.matchMedia("(pointer: coarse)");
    this.t(pointerQuery);
    pointerQuery.onchange = this.t.bind(this);
    const resize = new ResizeObserver(this.s.bind(this));
    resize.observe(el);
    effect(this.s.bind(this));
    this.dispatch("media-player-connect", {
      detail: this.el,
      bubbles: true,
      composed: true
    });
    return () => {
      resize.disconnect();
      pointerQuery.onchange = null;
    };
  }
  u() {
    const providedProps = {
      viewType: "providedViewType",
      streamType: "providedStreamType"
    };
    for (const prop2 of Object.keys(this.$props)) {
      this.$store[providedProps[prop2] ?? prop2]?.set(this.$props[prop2]());
    }
    effect(this.I.bind(this));
    this.$store.muted.set(this.$props.muted() || this.$props.volume() === 0);
  }
  w() {
    const { title } = this.$props, { live, viewType } = this.$store, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== "Unknown" ? `${isLive ? "Live " : ""}${type}` : isLive ? "Live" : "Media";
    const newTitle = title();
    if (newTitle) {
      this.el?.setAttribute("data-title", newTitle);
      this.el?.removeAttribute("title");
    }
    const currentTitle = this.el?.getAttribute("data-title") || "";
    this.$store.title.set(currentTitle);
    setAttribute(
      this.el,
      "aria-label",
      currentTitle ? `${typeText} - ${currentTitle}` : typeText + " Player"
    );
  }
  x() {
    const orientation = this.orientation.landscape ? "landscape" : "portrait";
    this.$store.orientation.set(orientation);
    setAttribute(this.el, "data-orientation", orientation);
    this.s();
  }
  y() {
    if (this.$store.canPlay() && this.m)
      this.p.M();
    else
      this.p.N();
  }
  I() {
    this.$store.providedViewType.set(this.$props.viewType());
    this.$store.providedStreamType.set(this.$props.streamType());
  }
  F() {
    const $attrs = {
      "aspect-ratio": this.$props.aspectRatio,
      "data-captions": () => {
        const track = this.$store.textTrack();
        return !!track && isTrackCaptionKind(track);
      },
      "data-ios-controls": this.n.$iosControls
    };
    const mediaAttrName = {
      canPictureInPicture: "can-pip",
      pictureInPicture: "pip"
    };
    for (const prop2 of MEDIA_ATTRIBUTES) {
      const attrName = "data-" + (mediaAttrName[prop2] ?? camelToKebabCase(prop2));
      $attrs[attrName] = this.$store[prop2];
    }
    delete $attrs.title;
    this.setAttributes($attrs);
  }
  G() {
    this.setCSSVars({
      "--media-aspect-ratio": () => {
        const ratio = this.$props.aspectRatio();
        return ratio ? +ratio.toFixed(4) : null;
      }
    });
  }
  H(event) {
    event.detail(this.el);
  }
  s() {
    if (!this.el)
      return;
    const width = this.el.clientWidth, height = this.el.clientHeight, { smallBreakpointX, smallBreakpointY, largeBreakpointX, largeBreakpointY } = this.$props, bpx = width < smallBreakpointX() ? "sm" : width < largeBreakpointX() ? "md" : "lg", bpy = height < smallBreakpointY() ? "sm" : height < largeBreakpointY() ? "md" : "lg";
    this.$store.breakpointX.set(bpx);
    this.$store.breakpointY.set(bpy);
    setAttribute(this.el, "data-bp-x", bpx);
    setAttribute(this.el, "data-bp-y", bpy);
  }
  t(queryList) {
    const isTouch = queryList.matches;
    setAttribute(this.el, "data-touch", isTouch);
    this.$store.touchPointer.set(isTouch);
    this.s();
  }
  v() {
    return !canFullscreen() && this.$store.mediaType() === "video" && (this.$store.controls() && !this.$props.playsinline() || this.$store.fullscreen());
  }
  get provider() {
    return this.m;
  }
  get user() {
    return this.o.O;
  }
  orientation;
  get qualities() {
    return this.n.qualities;
  }
  get audioTracks() {
    return this.n.audioTracks;
  }
  get textTracks() {
    return this.n.textTracks;
  }
  get textRenderers() {
    return this.n.textRenderers;
  }
  get paused() {
    return this.m?.paused ?? true;
  }
  set paused(paused) {
    if (paused) {
      this.p.q("paused", () => this.o.J());
    } else
      this.p.q("paused", () => this.o.K());
  }
  A() {
    this.paused = this.$props.paused();
  }
  get muted() {
    return this.m?.muted ?? false;
  }
  set muted(muted) {
    this.p.q("muted", () => this.m.muted = muted);
  }
  z() {
    this.muted = this.$props.muted();
  }
  get currentTime() {
    return this.m?.currentTime ?? 0;
  }
  set currentTime(time) {
    this.p.q("currentTime", () => {
      const adapter = this.m;
      if (time !== adapter.currentTime) {
        peek(() => {
          const boundTime = Math.min(
            Math.max(this.$store.seekableStart() + 0.1, time),
            this.$store.seekableEnd() - 0.1
          );
          if (Number.isFinite(boundTime))
            adapter.currentTime = boundTime;
        });
      }
    });
  }
  C() {
    this.currentTime = this.$props.currentTime();
  }
  get volume() {
    return this.m?.volume ?? 1;
  }
  set volume(volume) {
    this.p.q("volume", () => this.m.volume = volume);
  }
  B() {
    this.volume = clampNumber(0, this.$props.volume(), 1);
  }
  get playsinline() {
    return this.m?.playsinline ?? false;
  }
  set playsinline(inline) {
    this.p.q("playsinline", () => this.m.playsinline = inline);
  }
  D() {
    this.playsinline = this.$props.playsinline();
  }
  get playbackRate() {
    return this.m?.playbackRate ?? 1;
  }
  set playbackRate(rate) {
    this.p.q("rate", () => this.m.playbackRate = rate);
  }
  E() {
    this.playbackRate = this.$props.playbackRate();
  }
  async play() {
    return this.o.K();
  }
  async pause() {
    return this.o.J();
  }
  async enterFullscreen(target) {
    return this.o.P(target);
  }
  async exitFullscreen(target) {
    return this.o.Q(target);
  }
  enterPictureInPicture() {
    return this.o.R();
  }
  exitPictureInPicture() {
    return this.o.S();
  }
  seekToLiveEdge() {
    this.o.T();
  }
  startLoading() {
    this.n.delegate.U("can-load");
  }
  destroy() {
    this.dispatch("destroy");
  }
}
__decorateClass([
  prop
], Player.prototype, "provider", 1);
__decorateClass([
  prop
], Player.prototype, "user", 1);
__decorateClass([
  prop
], Player.prototype, "orientation", 2);
__decorateClass([
  prop
], Player.prototype, "qualities", 1);
__decorateClass([
  prop
], Player.prototype, "audioTracks", 1);
__decorateClass([
  prop
], Player.prototype, "textTracks", 1);
__decorateClass([
  prop
], Player.prototype, "textRenderers", 1);
__decorateClass([
  prop
], Player.prototype, "paused", 1);
__decorateClass([
  prop
], Player.prototype, "muted", 1);
__decorateClass([
  prop
], Player.prototype, "currentTime", 1);
__decorateClass([
  prop
], Player.prototype, "volume", 1);
__decorateClass([
  prop
], Player.prototype, "playsinline", 1);
__decorateClass([
  prop
], Player.prototype, "playbackRate", 1);
__decorateClass([
  method
], Player.prototype, "play", 1);
__decorateClass([
  method
], Player.prototype, "pause", 1);
__decorateClass([
  method
], Player.prototype, "enterFullscreen", 1);
__decorateClass([
  method
], Player.prototype, "exitFullscreen", 1);
__decorateClass([
  method
], Player.prototype, "enterPictureInPicture", 1);
__decorateClass([
  method
], Player.prototype, "exitPictureInPicture", 1);
__decorateClass([
  method
], Player.prototype, "seekToLiveEdge", 1);
__decorateClass([
  method
], Player.prototype, "startLoading", 1);

export { Player as P };
