import {
  ENABLE_AUTO_QUALITY,
  IS_CHROME,
  IS_SAFARI,
  LIST_ADD,
  LIST_REMOVE,
  LIST_SELECT,
  SET_AUTO_QUALITY,
  TEXT_TRACK_ON_MODE_CHANGE,
  TEXT_TRACK_READY_STATE,
  TextTrack,
  getNumberOfDecimalPlaces,
  isHLSSrc,
  isMediaStream
} from "./chunk-HZMNTWTL.js";
import {
  DOMEvent,
  camelToKebabCase,
  effect2 as effect,
  isNil,
  isNumber,
  isString,
  isUndefined,
  listenEvent,
  onDispose,
  peek,
  setAttribute,
  useDisposalBin
} from "./chunk-QXXJFF7J.js";
import {
  __publicField
} from "./chunk-TCQZMY3T.js";

// node_modules/vidstack/dist/dev/providers/hls/hls.js
var RAFLoop = class {
  constructor(_callback) {
    __publicField(this, "_id");
    this._callback = _callback;
  }
  _start() {
    if (!isUndefined(this._id))
      return;
    this._loop();
  }
  _stop() {
    if (isNumber(this._id))
      window.cancelAnimationFrame(this._id);
    this._id = void 0;
  }
  _loop() {
    this._id = window.requestAnimationFrame(() => {
      if (isUndefined(this._id))
        return;
      this._callback();
      this._loop();
    });
  }
};
var toDOMEventType = (type) => camelToKebabCase(type);
var HLSController = class {
  constructor(_video) {
    __publicField(this, "_context");
    __publicField(this, "_instance", null);
    __publicField(this, "_stopLiveSync", null);
    __publicField(this, "_config", {});
    __publicField(this, "_callbacks", /* @__PURE__ */ new Set());
    this._video = _video;
  }
  get instance() {
    return this._instance;
  }
  setup(ctor, context) {
    this._context = context;
    const isLive = peek(context.$store.streamType).includes("live"), isLiveLowLatency = peek(context.$store.streamType).includes("ll-");
    this._instance = new ctor({
      lowLatencyMode: isLiveLowLatency,
      backBufferLength: isLiveLowLatency ? 4 : isLive ? 8 : void 0,
      renderTextTracksNatively: false,
      ...this._config
    });
    const dispatcher = this._dispatchHLSEvent.bind(this);
    for (const event2 of Object.values(ctor.Events))
      this._instance.on(event2, dispatcher);
    this._instance.on(ctor.Events.ERROR, this._onError.bind(this));
    for (const callback of this._callbacks)
      callback(this._instance);
    context.player.dispatchEvent(new DOMEvent("hls-instance", { detail: this._instance }));
    this._instance.attachMedia(this._video);
    this._instance.on(ctor.Events.AUDIO_TRACK_SWITCHED, this._onAudioSwitch.bind(this));
    this._instance.on(ctor.Events.LEVEL_SWITCHED, this._onLevelSwitched.bind(this));
    this._instance.on(ctor.Events.LEVEL_LOADED, this._onLevelLoaded.bind(this));
    this._instance.on(ctor.Events.NON_NATIVE_TEXT_TRACKS_FOUND, this._onTracksFound.bind(this));
    this._instance.on(ctor.Events.CUES_PARSED, this._onCuesParsed.bind(this));
    context.qualities[ENABLE_AUTO_QUALITY] = this._enableAutoQuality.bind(this);
    listenEvent(context.qualities, "change", this._onQualityChange.bind(this));
    listenEvent(context.audioTracks, "change", this._onAudioChange.bind(this));
    this._stopLiveSync = effect(this._liveSync.bind(this));
  }
  _liveSync() {
    if (!this._context.$store.live())
      return;
    const raf = new RAFLoop(this._liveSyncPosition.bind(this));
    raf._start();
    return raf._stop.bind(raf);
  }
  _liveSyncPosition() {
    var _a;
    this._context.$store.liveSyncPosition.set(((_a = this._instance) == null ? void 0 : _a.liveSyncPosition) ?? Infinity);
  }
  _dispatchHLSEvent(eventType, detail) {
    this._context.player.dispatchEvent(new DOMEvent(toDOMEventType(eventType), { detail }));
  }
  _onTracksFound(eventType, data) {
    const event2 = new DOMEvent(eventType, { detail: data });
    let currentTrack = -1;
    for (let i = 0; i < data.tracks.length; i++) {
      const nonNativeTrack = data.tracks[i], init = nonNativeTrack.subtitleTrack ?? nonNativeTrack.closedCaptions, track = new TextTrack({
        id: `hls-${nonNativeTrack.kind}${i}`,
        src: init == null ? void 0 : init.url,
        label: nonNativeTrack.label,
        language: init == null ? void 0 : init.lang,
        kind: nonNativeTrack.kind
      });
      track[TEXT_TRACK_READY_STATE] = 2;
      track[TEXT_TRACK_ON_MODE_CHANGE] = () => {
        if (track.mode === "showing") {
          this._instance.subtitleTrack = i;
          currentTrack = i;
        } else if (currentTrack === i) {
          this._instance.subtitleTrack = -1;
          currentTrack = -1;
        }
      };
      if (nonNativeTrack.default)
        track.setMode("showing", event2);
      this._context.textTracks.add(track, event2);
    }
  }
  _onCuesParsed(eventType, data) {
    const track = this._context.textTracks.getById(`hls-${data.track}`);
    if (!track)
      return;
    const event2 = new DOMEvent(eventType, { detail: data });
    for (const cue of data.cues) {
      cue.positionAlign = "auto";
      track.addCue(cue, event2);
    }
  }
  _onAudioSwitch(eventType, data) {
    const track = this._context.audioTracks[data.id];
    if (track) {
      this._context.audioTracks[LIST_SELECT](
        track,
        true,
        new DOMEvent(eventType, { detail: data })
      );
    }
  }
  _onLevelSwitched(eventType, data) {
    const quality = this._context.qualities[data.level];
    if (quality) {
      this._context.qualities[LIST_SELECT](
        quality,
        true,
        new DOMEvent(eventType, { detail: data })
      );
    }
  }
  _onLevelLoaded(eventType, data) {
    if (this._context.$store.canPlay())
      return;
    const { type, live, totalduration: duration } = data.details;
    const event2 = new DOMEvent(eventType, { detail: data });
    this._context.delegate._dispatch("stream-type-change", {
      detail: live ? type === "EVENT" && Number.isFinite(duration) ? "live:dvr" : "live" : "on-demand",
      trigger: event2
    });
    this._context.delegate._dispatch("duration-change", { detail: duration, trigger: event2 });
    const media = this._instance.media;
    if (this._instance.currentLevel === -1) {
      this._context.qualities[SET_AUTO_QUALITY](true, event2);
    }
    for (const track of this._instance.audioTracks) {
      this._context.audioTracks[LIST_ADD](
        {
          id: track.id + "",
          label: track.name,
          language: track.lang || "",
          kind: "main"
        },
        event2
      );
    }
    for (const level of this._instance.levels) {
      this._context.qualities[LIST_ADD](
        {
          width: level.width,
          height: level.height,
          codec: level.codecSet,
          bitrate: level.bitrate
        },
        event2
      );
    }
    media.dispatchEvent(new DOMEvent("canplay", { trigger: event2 }));
  }
  _onError(eventType, data) {
    var _a, _b, _c, _d, _e;
    {
      (_b = this._context.logger) == null ? void 0 : _b.errorGroup(`HLS error \`${eventType}\``).labelledLog("Media Element", (_a = this._instance) == null ? void 0 : _a.media).labelledLog("HLS Instance", this._instance).labelledLog("Event Type", eventType).labelledLog("Data", data).labelledLog("Src", peek(this._context.$store.source)).labelledLog("Media Store", { ...this._context.$store }).dispatch();
    }
    if (data.fatal) {
      switch (data.type) {
        case "networkError":
          (_c = this._instance) == null ? void 0 : _c.startLoad();
          break;
        case "mediaError":
          (_d = this._instance) == null ? void 0 : _d.recoverMediaError();
          break;
        default:
          (_e = this._instance) == null ? void 0 : _e.destroy();
          this._instance = null;
          break;
      }
    }
  }
  _enableAutoQuality() {
    if (this._instance)
      this._instance.currentLevel = -1;
  }
  _onQualityChange() {
    const { qualities } = this._context;
    if (!this._instance || qualities.auto)
      return;
    this._instance[qualities.switch + "Level"] = qualities.selectedIndex;
    if (IS_CHROME)
      this._video.currentTime = this._video.currentTime;
  }
  _onAudioChange() {
    const { audioTracks } = this._context;
    if (this._instance && this._instance.audioTrack !== audioTracks.selectedIndex) {
      this._instance.audioTrack = audioTracks.selectedIndex;
    }
  }
  _destroy() {
    var _a, _b, _c, _d;
    if (this._context)
      this._context.qualities[ENABLE_AUTO_QUALITY] = void 0;
    (_a = this._instance) == null ? void 0 : _a.destroy();
    this._instance = null;
    (_b = this._stopLiveSync) == null ? void 0 : _b.call(this);
    this._stopLiveSync = null;
    (_d = (_c = this._context) == null ? void 0 : _c.logger) == null ? void 0 : _d.info("üèóÔ∏è Destroyed HLS instance");
  }
};

// node_modules/vidstack/dist/dev/providers/html/html‚Äìmedia-events.js
var HTMLMediaEvents = class {
  constructor(_provider, _context) {
    __publicField(this, "_disposal", useDisposalBin());
    __publicField(this, "_waiting", false);
    __publicField(this, "_attachedLoadStart", false);
    __publicField(this, "_attachedCanPlay", false);
    __publicField(this, "_timeRAF", new RAFLoop(this._onRAF.bind(this)));
    __publicField(this, "_handlers", /* @__PURE__ */ new Map());
    __publicField(this, "_handleDevEvent", this._onDevEvent.bind(this));
    this._provider = _provider;
    this._context = _context;
    this._attachInitialListeners();
    effect(this._attachTimeUpdate.bind(this));
    onDispose(this._onDispose.bind(this));
  }
  get _media() {
    return this._provider.media;
  }
  get _delegate() {
    return this._context.delegate;
  }
  _onDispose() {
    this._timeRAF._stop();
    this._disposal.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  _onRAF() {
    const newTime = this._provider.currentTime;
    if (this._context.$store.currentTime() !== newTime)
      this._updateCurrentTime(newTime);
  }
  _attachInitialListeners() {
    var _a;
    this._attachEventListener("loadstart", this._onLoadStart);
    this._attachEventListener("abort", this._onAbort);
    this._attachEventListener("emptied", this._onEmptied);
    this._attachEventListener("error", this._onError);
    (_a = this._context.logger) == null ? void 0 : _a.debug("attached initial media event listeners");
  }
  _attachLoadStartListeners() {
    if (this._attachedLoadStart)
      return;
    this._disposal.add(
      this._attachEventListener("loadeddata", this._onLoadedData),
      this._attachEventListener("loadedmetadata", this._onLoadedMetadata),
      this._attachEventListener("canplay", this._onCanPlay),
      this._attachEventListener("canplaythrough", this._onCanPlayThrough),
      this._attachEventListener("durationchange", this._onDurationChange),
      this._attachEventListener("play", this._onPlay),
      this._attachEventListener("progress", this._onProgress),
      this._attachEventListener("stalled", this._onStalled),
      this._attachEventListener("suspend", this._onSuspend)
    );
    this._attachedLoadStart = true;
  }
  _attachCanPlayListeners() {
    if (this._attachedCanPlay)
      return;
    this._disposal.add(
      this._attachEventListener("pause", this._onPause),
      this._attachEventListener("playing", this._onPlaying),
      this._attachEventListener("ratechange", this._onRateChange),
      this._attachEventListener("seeked", this._onSeeked),
      this._attachEventListener("seeking", this._onSeeking),
      this._attachEventListener("ended", this._onEnded),
      this._attachEventListener("volumechange", this._onVolumeChange),
      this._attachEventListener("waiting", this._onWaiting)
    );
    this._attachedCanPlay = true;
  }
  _attachEventListener(eventType, handler) {
    this._handlers.set(eventType, handler);
    return listenEvent(
      this._media,
      eventType,
      this._handleDevEvent
    );
  }
  _onDevEvent(event2) {
    var _a, _b;
    (_a = this._context.logger) == null ? void 0 : _a.debugGroup(`üì∫ fired \`${event2.type}\``).labelledLog("Event", event2).labelledLog("Media Store", { ...this._context.$store }).dispatch();
    (_b = this._handlers.get(event2.type)) == null ? void 0 : _b.call(this, event2);
  }
  _updateCurrentTime(time, trigger) {
    this._delegate._dispatch("time-update", {
      // Avoid errors where `currentTime` can have higher precision.
      detail: {
        currentTime: Math.min(time, this._context.$store.seekableEnd()),
        played: this._media.played
      },
      trigger
    });
  }
  _onLoadStart(event2) {
    if (this._media.networkState === 3) {
      this._onAbort(event2);
      return;
    }
    this._attachLoadStartListeners();
    this._delegate._dispatch("load-start", { trigger: event2 });
  }
  _onAbort(event2) {
    this._delegate._dispatch("abort", { trigger: event2 });
  }
  _onEmptied() {
    this._delegate._dispatch("emptied", { trigger: event });
  }
  _onLoadedData(event2) {
    this._delegate._dispatch("loaded-data", { trigger: event2 });
  }
  _onLoadedMetadata(event2) {
    this._onStreamTypeChange();
    this._attachCanPlayListeners();
    this._delegate._dispatch("volume-change", {
      detail: {
        volume: this._media.volume,
        muted: this._media.muted
      }
    });
    this._delegate._dispatch("loaded-metadata", { trigger: event2 });
    if (IS_SAFARI && isHLSSrc(this._context.$store.source())) {
      this._delegate._ready(this._getCanPlayDetail(), event2);
    }
  }
  _getCanPlayDetail() {
    return {
      duration: this._media.duration,
      buffered: this._media.buffered,
      seekable: this._media.seekable
    };
  }
  _onStreamTypeChange() {
    const isLive = !Number.isFinite(this._media.duration);
    this._delegate._dispatch("stream-type-change", {
      detail: isLive ? "live" : "on-demand"
    });
  }
  _onPlay(event2) {
    if (!this._context.$store.canPlay)
      return;
    this._delegate._dispatch("play", { trigger: event2 });
  }
  _onPause(event2) {
    if (this._media.readyState === 1 && !this._waiting)
      return;
    this._waiting = false;
    this._timeRAF._stop();
    this._delegate._dispatch("pause", { trigger: event2 });
  }
  _onCanPlay(event2) {
    this._delegate._ready(this._getCanPlayDetail(), event2);
  }
  _onCanPlayThrough(event2) {
    if (this._context.$store.started())
      return;
    this._delegate._dispatch("can-play-through", {
      trigger: event2,
      detail: this._getCanPlayDetail()
    });
  }
  _onPlaying(event2) {
    this._waiting = false;
    this._delegate._dispatch("playing", { trigger: event2 });
    this._timeRAF._start();
  }
  _onStalled(event2) {
    this._delegate._dispatch("stalled", { trigger: event2 });
    if (this._media.readyState < 3) {
      this._waiting = true;
      this._delegate._dispatch("waiting", { trigger: event2 });
    }
  }
  _onWaiting(event2) {
    if (this._media.readyState < 3) {
      this._waiting = true;
      this._delegate._dispatch("waiting", { trigger: event2 });
    }
  }
  _onEnded(event2) {
    this._timeRAF._stop();
    this._updateCurrentTime(this._media.duration, event2);
    this._delegate._dispatch("end", { trigger: event2 });
    if (this._context.$store.loop()) {
      this._onLoop();
    } else {
      this._delegate._dispatch("ended", { trigger: event2 });
    }
  }
  _attachTimeUpdate() {
    if (this._context.$store.paused()) {
      listenEvent(this._media, "timeupdate", this._onTimeUpdate.bind(this));
    }
  }
  _onTimeUpdate(event2) {
    this._updateCurrentTime(this._media.currentTime, event2);
  }
  _onDurationChange(event2) {
    this._onStreamTypeChange();
    if (this._context.$store.ended()) {
      this._updateCurrentTime(this._media.duration, event2);
    }
    this._delegate._dispatch("duration-change", {
      detail: this._media.duration,
      trigger: event2
    });
  }
  _onVolumeChange(event2) {
    this._delegate._dispatch("volume-change", {
      detail: {
        volume: this._media.volume,
        muted: this._media.muted
      },
      trigger: event2
    });
  }
  _onSeeked(event2) {
    this._updateCurrentTime(this._media.currentTime, event2);
    this._delegate._dispatch("seeked", {
      detail: this._media.currentTime,
      trigger: event2
    });
    if (Math.trunc(this._media.currentTime) === Math.trunc(this._media.duration) && getNumberOfDecimalPlaces(this._media.duration) > getNumberOfDecimalPlaces(this._media.currentTime)) {
      this._updateCurrentTime(this._media.duration, event2);
      if (!this._media.ended) {
        this._context.player.dispatchEvent(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  _onSeeking(event2) {
    this._delegate._dispatch("seeking", {
      detail: this._media.currentTime,
      trigger: event2
    });
  }
  _onProgress(event2) {
    this._delegate._dispatch("progress", {
      detail: {
        buffered: this._media.buffered,
        seekable: this._media.seekable
      },
      trigger: event2
    });
  }
  _onLoop() {
    const hasCustomControls = isNil(this._media.controls);
    if (hasCustomControls)
      this._media.controls = false;
    this._context.player.dispatchEvent(new DOMEvent("media-loop-request"));
  }
  _onSuspend(event2) {
    this._delegate._dispatch("suspend", { trigger: event2 });
  }
  _onRateChange(event2) {
    this._delegate._dispatch("rate-change", {
      detail: this._media.playbackRate,
      trigger: event2
    });
  }
  _onError(event2) {
    const error = this._media.error;
    if (!error)
      return;
    this._delegate._dispatch("error", {
      detail: {
        message: error.message,
        code: error.code,
        mediaError: error
      },
      trigger: event2
    });
  }
};

// node_modules/vidstack/dist/dev/providers/html/native-audio-tracks.js
var NativeAudioTracks = class {
  constructor(_provider, _context) {
    this._provider = _provider;
    this._context = _context;
    this._nativeTracks.onaddtrack = this._onAddNativeTrack.bind(this);
    this._nativeTracks.onremovetrack = this._onRemoveNativeTrack.bind(this);
    this._nativeTracks.onchange = this._onChangeNativeTrack.bind(this);
    listenEvent(this._context.audioTracks, "change", this._onChangeTrack.bind(this));
  }
  get _nativeTracks() {
    return this._provider.media.audioTracks;
  }
  _onAddNativeTrack(event2) {
    const _track = event2.track;
    if (_track.label === "")
      return;
    const audioTrack = {
      id: _track.id + "",
      label: _track.label,
      language: _track.language,
      kind: _track.kind,
      selected: false
    };
    this._context.audioTracks[LIST_ADD](audioTrack, event2);
    if (_track.enabled)
      audioTrack.selected = true;
  }
  _onRemoveNativeTrack(event2) {
    const track = this._context.audioTracks.getById(event2.track.id);
    if (track)
      this._context.audioTracks[LIST_REMOVE](track, event2);
  }
  _onChangeNativeTrack(event2) {
    let enabledTrack = this._getEnabledNativeTrack();
    if (!enabledTrack)
      return;
    const track = this._context.audioTracks.getById(enabledTrack.id);
    if (track)
      this._context.audioTracks[LIST_SELECT](track, true, event2);
  }
  _getEnabledNativeTrack() {
    return Array.from(this._nativeTracks).find((track) => track.enabled);
  }
  _onChangeTrack(event2) {
    const { current } = event2.detail;
    if (!current)
      return;
    const track = this._nativeTracks.getTrackById(current.id);
    if (track) {
      const prev = this._getEnabledNativeTrack();
      if (prev)
        prev.enabled = false;
      track.enabled = true;
    }
  }
};

// node_modules/vidstack/dist/dev/providers/html/provider.js
var HTMLMediaProvider = class {
  constructor(_media) {
    this._media = _media;
  }
  setup(context) {
    new HTMLMediaEvents(this, context);
    if ("audioTracks" in this.media)
      new NativeAudioTracks(this, context);
  }
  get type() {
    return "";
  }
  get media() {
    return this._media;
  }
  get paused() {
    return this._media.paused;
  }
  get muted() {
    return this._media.muted;
  }
  set muted(muted) {
    this._media.muted = muted;
  }
  get volume() {
    return this._media.volume;
  }
  set volume(volume) {
    this._media.volume = volume;
  }
  get currentTime() {
    return this._media.currentTime;
  }
  set currentTime(time) {
    this._media.currentTime = time;
  }
  get playsinline() {
    return this._media.hasAttribute("playsinline");
  }
  set playsinline(playsinline) {
    setAttribute(this._media, "playsinline", playsinline);
  }
  get playbackRate() {
    return this._media.playbackRate;
  }
  set playbackRate(rate) {
    this._media.playbackRate = rate;
  }
  async play() {
    return this._media.play();
  }
  async pause() {
    return this._media.pause();
  }
  async loadSource({ src }, preload) {
    this._media.preload = preload;
    if (isMediaStream(src)) {
      this._media.srcObject = src;
    } else {
      this._media.srcObject = null;
      this._media.src = isString(src) ? src : window.URL.createObjectURL(src);
    }
    this._media.load();
  }
};

export {
  HLSController,
  HTMLMediaProvider
};
//# sourceMappingURL=chunk-JSCW43BU.js.map
