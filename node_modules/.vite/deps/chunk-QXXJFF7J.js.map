{
  "version": 3,
  "sources": ["../../@maverick-js/signals/dist/dev/symbols.js", "../../@maverick-js/signals/dist/dev/core.js", "../../@maverick-js/signals/dist/dev/signals.js", "../../@maverick-js/signals/dist/dev/map.js", "../../maverick.js/dist/dev/chunks/chunk-NQ7TQAU7.js", "../../maverick.js/dist/dev/chunks/chunk-VABDA4SA.js", "../../maverick.js/dist/dev/std.js"],
  "sourcesContent": ["const SCOPE = Symbol(\"SCOPE\" );\n\nexport { SCOPE };\n", "import { SCOPE } from './symbols.js';\n\nlet scheduledEffects = false, runningEffects = false, currentScope = null, currentObserver = null, currentObservers = null, currentObserversIndex = 0, effects = [], defaultContext = {};\nconst NOOP = () => {\n}, STATE_CLEAN = 0, STATE_CHECK = 1, STATE_DIRTY = 2, STATE_DISPOSED = 3;\nfunction flushEffects() {\n  scheduledEffects = true;\n  queueMicrotask(runEffects);\n}\nfunction runEffects() {\n  if (!effects.length) {\n    scheduledEffects = false;\n    return;\n  }\n  runningEffects = true;\n  for (let i = 0; i < effects.length; i++) {\n    if (effects[i]._state !== STATE_CLEAN)\n      runTop(effects[i]);\n  }\n  effects = [];\n  scheduledEffects = false;\n  runningEffects = false;\n}\nfunction runTop(node) {\n  let ancestors = [node];\n  while (node = node[SCOPE]) {\n    if (node._effect && node._state !== STATE_CLEAN)\n      ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    updateCheck(ancestors[i]);\n  }\n}\nfunction root(init) {\n  const scope = createScope();\n  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);\n}\nfunction peek(fn) {\n  return compute(currentScope, fn, null);\n}\nfunction untrack(fn) {\n  return compute(null, fn, null);\n}\nfunction tick() {\n  if (!runningEffects)\n    runEffects();\n}\nfunction getScope() {\n  return currentScope;\n}\nfunction scoped(run, scope) {\n  try {\n    return compute(scope, run, null);\n  } catch (error) {\n    handleError(scope, error);\n    return;\n  }\n}\nfunction getContext(key, scope = currentScope) {\n  return scope?._context[key];\n}\nfunction setContext(key, value, scope = currentScope) {\n  if (scope)\n    scope._context = { ...scope._context, [key]: value };\n}\nfunction onError(handler) {\n  if (!currentScope)\n    return;\n  currentScope._handlers = currentScope._handlers ? [handler, ...currentScope._handlers] : [handler];\n}\nfunction onDispose(disposable) {\n  if (!disposable || !currentScope)\n    return disposable || NOOP;\n  const node = currentScope;\n  if (!node._disposal) {\n    node._disposal = disposable;\n  } else if (Array.isArray(node._disposal)) {\n    node._disposal.push(disposable);\n  } else {\n    node._disposal = [node._disposal, disposable];\n  }\n  return function removeDispose() {\n    if (node._state === STATE_DISPOSED)\n      return;\n    disposable.call(null);\n    if (isFunction(node._disposal)) {\n      node._disposal = null;\n    } else if (Array.isArray(node._disposal)) {\n      node._disposal.splice(node._disposal.indexOf(disposable), 1);\n    }\n  };\n}\nfunction dispose(self = true) {\n  if (this._state === STATE_DISPOSED)\n    return;\n  let head = self ? this._prevSibling ?? this[SCOPE] : this, current = this._nextSibling;\n  while (current && current[SCOPE] === this) {\n    dispose.call(current, true);\n    disposeNode(current);\n    current = current._nextSibling;\n  }\n  if (self)\n    disposeNode(this);\n  if (current)\n    current._prevSibling = !self ? this : this._prevSibling;\n  if (head)\n    head._nextSibling = current;\n}\nfunction disposeNode(node) {\n  node._state = STATE_DISPOSED;\n  if (node._disposal)\n    emptyDisposal(node);\n  if (node._sources)\n    removeSourceObservers(node, 0);\n  if (node._prevSibling)\n    node._prevSibling._nextSibling = null;\n  node[SCOPE] = null;\n  node._sources = null;\n  node._observers = null;\n  node._prevSibling = null;\n  node._context = defaultContext;\n  node._handlers = null;\n}\nfunction emptyDisposal(scope) {\n  try {\n    if (Array.isArray(scope._disposal)) {\n      for (let i = scope._disposal.length - 1; i >= 0; i--) {\n        const callable = scope._disposal[i];\n        callable.call(callable);\n      }\n    } else {\n      scope._disposal.call(scope._disposal);\n    }\n    scope._disposal = null;\n  } catch (error) {\n    handleError(scope, error);\n  }\n}\nfunction compute(scope, compute2, observer) {\n  const prevScope = currentScope, prevObserver = currentObserver;\n  currentScope = scope;\n  currentObserver = observer;\n  try {\n    return compute2.call(scope);\n  } finally {\n    currentScope = prevScope;\n    currentObserver = prevObserver;\n  }\n}\nfunction handleError(scope, error) {\n  if (!scope || !scope._handlers)\n    throw error;\n  let i = 0, len = scope._handlers.length, coercedError = coerceError(error);\n  for (i = 0; i < len; i++) {\n    try {\n      scope._handlers[i](coercedError);\n      break;\n    } catch (error2) {\n      coercedError = coerceError(error2);\n    }\n  }\n  if (i === len)\n    throw coercedError;\n}\nfunction coerceError(error) {\n  return error instanceof Error ? error : Error(JSON.stringify(error));\n}\nfunction read() {\n  if (this._state === STATE_DISPOSED)\n    return this._value;\n  if (currentObserver && !this._effect) {\n    if (!currentObservers && currentObserver._sources && currentObserver._sources[currentObserversIndex] == this) {\n      currentObserversIndex++;\n    } else if (!currentObservers)\n      currentObservers = [this];\n    else\n      currentObservers.push(this);\n  }\n  if (this._compute)\n    updateCheck(this);\n  return this._value;\n}\nfunction write(newValue) {\n  const value = isFunction(newValue) ? newValue(this._value) : newValue;\n  if (this._changed(this._value, value)) {\n    this._value = value;\n    if (this._observers) {\n      for (let i = 0; i < this._observers.length; i++) {\n        notify(this._observers[i], STATE_DIRTY);\n      }\n    }\n  }\n  return this._value;\n}\nconst ScopeNode = function Scope() {\n  this[SCOPE] = null;\n  this._nextSibling = null;\n  this._prevSibling = null;\n  if (currentScope)\n    currentScope.append(this);\n};\nconst ScopeProto = ScopeNode.prototype;\nScopeProto._context = defaultContext;\nScopeProto._handlers = null;\nScopeProto._compute = null;\nScopeProto._disposal = null;\nScopeProto.append = function(scope) {\n  scope[SCOPE] = this;\n  scope._prevSibling = this;\n  if (this._nextSibling)\n    this._nextSibling._prevSibling = scope;\n  scope._nextSibling = this._nextSibling;\n  this._nextSibling = scope;\n  scope._context = scope._context === defaultContext ? this._context : { ...this._context, ...scope._context };\n  if (this._handlers) {\n    scope._handlers = !scope._handlers ? this._handlers : [...scope._handlers, ...this._handlers];\n  }\n};\nScopeProto.dispose = function() {\n  dispose.call(this);\n};\nfunction createScope() {\n  return new ScopeNode();\n}\nconst ComputeNode = function Computation(initialValue, compute2, options) {\n  ScopeNode.call(this);\n  this._state = compute2 ? STATE_DIRTY : STATE_CLEAN;\n  this._init = false;\n  this._effect = false;\n  this._sources = null;\n  this._observers = null;\n  this._value = initialValue;\n  this.id = options?.id ?? (this._compute ? \"computed\" : \"signal\");\n  if (compute2)\n    this._compute = compute2;\n  if (options && options.dirty)\n    this._changed = options.dirty;\n};\nconst ComputeProto = ComputeNode.prototype;\nObject.setPrototypeOf(ComputeProto, ScopeProto);\nComputeProto._changed = isNotEqual;\nComputeProto.call = read;\nfunction createComputation(initialValue, compute2, options) {\n  return new ComputeNode(initialValue, compute2, options);\n}\nfunction isNotEqual(a, b) {\n  return a !== b;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction updateCheck(node) {\n  if (node._state === STATE_CHECK) {\n    for (let i = 0; i < node._sources.length; i++) {\n      updateCheck(node._sources[i]);\n      if (node._state === STATE_DIRTY) {\n        break;\n      }\n    }\n  }\n  if (node._state === STATE_DIRTY)\n    update(node);\n  else\n    node._state = STATE_CLEAN;\n}\nfunction cleanup(node) {\n  if (node._nextSibling && node._nextSibling[SCOPE] === node)\n    dispose.call(node, false);\n  if (node._disposal)\n    emptyDisposal(node);\n  node._handlers = node[SCOPE] ? node[SCOPE]._handlers : null;\n}\nfunction update(node) {\n  let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;\n  currentObservers = null;\n  currentObserversIndex = 0;\n  try {\n    cleanup(node);\n    const result = compute(node, node._compute, node);\n    if (currentObservers) {\n      if (node._sources)\n        removeSourceObservers(node, currentObserversIndex);\n      if (node._sources && currentObserversIndex > 0) {\n        node._sources.length = currentObserversIndex + currentObservers.length;\n        for (let i = 0; i < currentObservers.length; i++) {\n          node._sources[currentObserversIndex + i] = currentObservers[i];\n        }\n      } else {\n        node._sources = currentObservers;\n      }\n      let source;\n      for (let i = currentObserversIndex; i < node._sources.length; i++) {\n        source = node._sources[i];\n        if (!source._observers)\n          source._observers = [node];\n        else\n          source._observers.push(node);\n      }\n    } else if (node._sources && currentObserversIndex < node._sources.length) {\n      removeSourceObservers(node, currentObserversIndex);\n      node._sources.length = currentObserversIndex;\n    }\n    if (!node._effect && node._init) {\n      write.call(node, result);\n    } else {\n      node._value = result;\n      node._init = true;\n    }\n  } catch (error) {\n    if (!node._init && typeof node._value === \"undefined\") {\n      console.error(\n        `computed \\`${node.id}\\` threw error during first run, this can be fatal.\n\nSolutions:\n\n1. Set the \\`initial\\` option to silence this error`,\n        \"\\n2. Or, use an `effect` if the return value is not being used\",\n        \"\\n\\n\",\n        error\n      );\n    }\n    handleError(node, error);\n    if (node._state === STATE_DIRTY) {\n      cleanup(node);\n      if (node._sources)\n        removeSourceObservers(node, 0);\n    }\n    return;\n  }\n  currentObservers = prevObservers;\n  currentObserversIndex = prevObserversIndex;\n  node._state = STATE_CLEAN;\n}\nfunction notify(node, state) {\n  if (node._state >= state)\n    return;\n  if (node._effect && node._state === STATE_CLEAN) {\n    effects.push(node);\n    if (!scheduledEffects)\n      flushEffects();\n  }\n  node._state = state;\n  if (node._observers) {\n    for (let i = 0; i < node._observers.length; i++) {\n      notify(node._observers[i], STATE_CHECK);\n    }\n  }\n}\nfunction removeSourceObservers(node, index) {\n  let source, swap;\n  for (let i = index; i < node._sources.length; i++) {\n    source = node._sources[i];\n    if (source._observers) {\n      swap = source._observers.indexOf(node);\n      source._observers[swap] = source._observers[source._observers.length - 1];\n      source._observers.pop();\n    }\n  }\n}\n\nexport { compute, createComputation, createScope, dispose, getContext, getScope, isFunction, isNotEqual, onDispose, onError, peek, read, root, scoped, setContext, tick, untrack, update, write };\n", "import { createComputation, read, write, isFunction, onDispose, update, dispose } from './core.js';\nimport { SCOPE } from './symbols.js';\n\nfunction signal(initialValue, options) {\n  const node = createComputation(initialValue, null, options), signal2 = read.bind(node);\n  signal2.node = node;\n  signal2[SCOPE] = true;\n  signal2.set = write.bind(node);\n  return signal2;\n}\nfunction isReadSignal(fn) {\n  return isFunction(fn) && SCOPE in fn;\n}\nfunction computed(compute, options) {\n  const node = createComputation(\n    options?.initial,\n    compute,\n    options\n  ), signal2 = read.bind(node);\n  signal2[SCOPE] = true;\n  signal2.node = node;\n  return signal2;\n}\nfunction effect(effect2, options) {\n  const signal2 = createComputation(\n    null,\n    function runEffect() {\n      let effectResult = effect2();\n      isFunction(effectResult) && onDispose(effectResult);\n      return null;\n    },\n    { id: options?.id ?? \"effect\" } \n  );\n  signal2._effect = true;\n  update(signal2);\n  {\n    return function stopEffect() {\n      dispose.call(signal2, true);\n    };\n  }\n}\nfunction readonly(signal2) {\n  const readonly2 = () => signal2();\n  readonly2[SCOPE] = true;\n  readonly2.node = signal2.node;\n  return readonly2;\n}\nfunction isWriteSignal(fn) {\n  return isReadSignal(fn) && \"set\" in fn;\n}\n\nexport { computed, effect, isReadSignal, isWriteSignal, readonly, signal };\n", "import { write, onDispose, read, isNotEqual, createComputation, createScope, scoped, dispose, compute } from './core.js';\nimport { effect } from './signals.js';\nimport './symbols.js';\n\nfunction selector(source) {\n  let currentKey, nodes = /* @__PURE__ */ new Map();\n  effect(() => {\n    const newKey = source(), prev = nodes.get(currentKey), next = nodes.get(newKey);\n    prev && write.call(prev, false);\n    next && write.call(next, true);\n    currentKey = newKey;\n  });\n  return function observeSelector(key) {\n    let node = nodes.get(key);\n    if (!node)\n      nodes.set(key, node = new Selector(key, key === currentKey, nodes));\n    node._refs += 1;\n    onDispose(node);\n    return read.bind(node);\n  };\n}\nfunction Selector(key, initialValue, nodes) {\n  this._state = /** CLEAN */\n  0;\n  this._key = key;\n  this._value = initialValue;\n  this._refs = 0;\n  this._nodes = nodes;\n  this._observers = null;\n}\nconst SelectorProto = Selector.prototype;\nSelectorProto._changed = isNotEqual;\nSelectorProto.call = function() {\n  this._refs -= 1;\n  if (!this._refs) {\n    this._nodes.delete(this._key);\n    this._nodes = null;\n  }\n};\n\nfunction computedMap(list, map, options) {\n  return read.bind(\n    createComputation(\n      [],\n      updateMap.bind({\n        _scope: createScope(),\n        _len: 0,\n        _list: list,\n        _items: [],\n        _map: map,\n        _mappings: [],\n        _nodes: []\n      }),\n      options\n    )\n  );\n}\nfunction updateMap() {\n  let i = 0, newItems = this._list() || [], mapper = () => this._map(read.bind(this._nodes[i]), i);\n  scoped(() => {\n    if (newItems.length === 0) {\n      if (this._len !== 0) {\n        dispose.call(this._scope, false);\n        this._items = [];\n        this._mappings = [];\n        this._len = 0;\n        this._nodes = [];\n      }\n      return;\n    }\n    for (i = 0; i < newItems.length; i++) {\n      if (i < this._items.length && this._items[i] !== newItems[i]) {\n        write.call(this._nodes[i], newItems[i]);\n      } else if (i >= this._items.length) {\n        this._mappings[i] = compute(\n          this._nodes[i] = createComputation(newItems[i], null),\n          mapper,\n          null\n        );\n      }\n    }\n    for (; i < this._items.length; i++)\n      dispose.call(this._nodes[i]);\n    this._len = this._nodes.length = newItems.length;\n    this._items = newItems.slice(0);\n    this._mappings = this._mappings.slice(0, this._len);\n  }, this._scope);\n  return this._mappings;\n}\nfunction computedKeyedMap(list, map, options) {\n  return read.bind(\n    createComputation(\n      [],\n      updateKeyedMap.bind({\n        _scope: createScope(),\n        _len: 0,\n        _list: list,\n        _items: [],\n        _map: map,\n        _mappings: [],\n        _nodes: []\n      }),\n      options\n    )\n  );\n}\nfunction updateKeyedMap() {\n  const newItems = this._list() || [], indexed = this._map.length > 1;\n  scoped(() => {\n    let newLen = newItems.length, i, j, mapper = indexed ? () => this._map(newItems[j], read.bind(this._nodes[j])) : () => this._map(newItems[j]);\n    if (newLen === 0) {\n      if (this._len !== 0) {\n        dispose.call(this._scope, false);\n        this._nodes = [];\n        this._items = [];\n        this._mappings = [];\n        this._len = 0;\n      }\n    } else if (this._len === 0) {\n      this._mappings = new Array(newLen);\n      for (j = 0; j < newLen; j++) {\n        this._items[j] = newItems[j];\n        this._mappings[j] = compute(\n          this._nodes[j] = createComputation(j, null),\n          mapper,\n          null\n        );\n      }\n      this._len = newLen;\n    } else {\n      let start, end, newEnd, item, newIndices, newIndicesNext, temp = new Array(newLen), tempNodes = new Array(newLen);\n      for (start = 0, end = Math.min(this._len, newLen); start < end && this._items[start] === newItems[start]; start++)\n        ;\n      for (end = this._len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && this._items[end] === newItems[newEnd]; end--, newEnd--) {\n        temp[newEnd] = this._mappings[end];\n        tempNodes[newEnd] = this._nodes[end];\n      }\n      newIndices = /* @__PURE__ */ new Map();\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = newItems[j];\n        i = newIndices.get(item);\n        newIndicesNext[j] = i === void 0 ? -1 : i;\n        newIndices.set(item, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = this._items[i];\n        j = newIndices.get(item);\n        if (j !== void 0 && j !== -1) {\n          temp[j] = this._mappings[i];\n          tempNodes[j] = this._nodes[i];\n          j = newIndicesNext[j];\n          newIndices.set(item, j);\n        } else\n          dispose.call(this._nodes[i]);\n      }\n      for (j = start; j < newLen; j++) {\n        if (j in temp) {\n          this._mappings[j] = temp[j];\n          this._nodes[j] = tempNodes[j];\n          write.call(this._nodes[j], j);\n        } else {\n          this._mappings[j] = compute(\n            this._nodes[j] = createComputation(j, null),\n            mapper,\n            null\n          );\n        }\n      }\n      this._mappings = this._mappings.slice(0, this._len = newLen);\n      this._items = newItems.slice(0);\n    }\n  }, this._scope);\n  return this._mappings;\n}\n\nexport { computedKeyedMap, computedMap, selector };\n", "import { setContext, getScope, getContext, computed, signal, effect as effect$1, onError, peek } from '@maverick-js/signals';\nexport { computed, createScope, getScope, isReadSignal, isWriteSignal, onDispose, onError, peek, readonly, root, scoped, signal, tick, untrack } from '@maverick-js/signals';\nimport { computedMap, computedKeyedMap } from '@maverick-js/signals/map';\n\n// src/runtime/accessors.ts\nfunction createAccessors(record) {\n  const accessors = {};\n  for (const name of Object.keys(record)) {\n    Object.defineProperty(accessors, name, {\n      configurable: true,\n      enumerable: true,\n      get: record[name],\n      set: record[name].set\n    });\n  }\n  return accessors;\n}\n\n// src/std/unit.ts\nfunction noop(...args) {\n}\nfunction isNull(value) {\n  return value === null;\n}\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\nfunction isNil(value) {\n  return isNull(value) || isUndefined(value);\n}\nfunction isObject(value) {\n  return value?.constructor === Object;\n}\nfunction isNumber(value) {\n  return typeof value === \"number\" && !Number.isNaN(value);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction createRegex(regex) {\n  return isString(regex) ? new RegExp(regex) : regex;\n}\nfunction isWindow(value) {\n  return value === window;\n}\nfunction createContext(provide) {\n  return { id: Symbol(), provide };\n}\nfunction provideContext(context, value, scope = getScope()) {\n  if (!scope) {\n    throw Error(\"[maverick] attempting to provide context outside `root` or `setup` function\");\n  }\n  const hasProvidedValue = !isUndefined(value);\n  if (!hasProvidedValue && !context.provide) {\n    throw Error(\"[maverick] context can not be provided without a value or `provide` function\");\n  }\n  setContext(context.id, hasProvidedValue ? value : context.provide?.(), scope);\n}\nfunction useContext(context) {\n  const value = getContext(context.id);\n  if (isUndefined(value)) {\n    throw Error(\"[maverick] attempting to use context without providing first\");\n  }\n  return value;\n}\nfunction hasProvidedContext(context) {\n  return !isUndefined(getContext(context.id));\n}\n\n// src/runtime/store.ts\nvar StoreFactory = class {\n  constructor(record) {\n    this.id = Symbol(\"STORE\" );\n    this.record = record;\n    this._descriptors = Object.getOwnPropertyDescriptors(record);\n  }\n  create() {\n    const store = {}, state = new Proxy(store, { get: (_, prop) => store[prop]() });\n    for (const name of Object.keys(this.record)) {\n      const getter = this._descriptors[name].get;\n      store[name] = getter ? computed(getter.bind(state)) : signal(this.record[name]);\n    }\n    return store;\n  }\n  reset(record, filter) {\n    for (const name of Object.keys(record)) {\n      if (!this._descriptors[name].get && (!filter || filter(name))) {\n        record[name].set(this.record[name]);\n      }\n    }\n  }\n};\nfunction useStore(store) {\n  return useContext(store);\n}\n\n// src/runtime/reactivity.ts\nvar effect = effect$1;\n\n// src/std/signal.ts\nfunction unwrap(fn) {\n  return isFunction(fn) ? fn() : fn;\n}\nfunction unwrapDeep(fn) {\n  let value = fn;\n  while (typeof value === \"function\")\n    value = value();\n  return value;\n}\n\n// src/runtime/components/ErrorBoundary.ts\nfunction ErrorBoundary(props) {\n  const $e = signal(null);\n  const $error = () => $e();\n  $error.handled = () => $e.set(null);\n  return computed(\n    () => {\n      const $children = unwrap(props.$children);\n      onError((error) => {\n        if ($children.length === 0)\n          console.error(error);\n        $e.set(error);\n        props.onError?.(error, $error.handled);\n      });\n      return isFunction($children) && $children.length > 0 ? peek(() => $children($error)) : $children;\n    },\n    { initial: null }\n  );\n}\nfunction For(props) {\n  return computedMap(\n    () => unwrap(props.each),\n    unwrap(props.$children),\n    { id: \"For\" } \n  );\n}\nfunction ForKeyed(props) {\n  return computedKeyedMap(\n    () => unwrap(props.each),\n    unwrap(props.$children),\n    { id: \"ForKeyed\" } \n  );\n}\n\nexport { ErrorBoundary, For, ForKeyed, StoreFactory, createAccessors, createContext, createRegex, effect, hasProvidedContext, isArray, isBoolean, isFunction, isNil, isNull, isNumber, isObject, isString, isUndefined, isWindow, noop, provideContext, unwrap, unwrapDeep, useContext, useStore };\n", "import { onDispose, isArray } from './chunk-NQ7TQAU7.js';\n\n// src/std/event.ts\nvar EVENT = Event;\nvar DOM_EVENT = Symbol(\"DOM_EVENT\");\nvar _a;\nvar DOMEvent = class extends EVENT {\n  constructor(type, ...init) {\n    super(type, init[0]);\n    this[_a] = true;\n    this.detail = init[0]?.detail;\n    this.trigger = init[0]?.trigger;\n  }\n  /**\n   * Walks up the event chain (following each `trigger`) and returns the origin event\n   * that started the chain.\n   */\n  get originEvent() {\n    return getOriginEvent(this) ?? this;\n  }\n  /**\n   * Walks up the event chain (following each `trigger`) and determines whether the initial\n   * event was triggered by the end user (ie: check whether `isTrusted` on the `originEvent` `true`).\n   */\n  get isOriginTrusted() {\n    return getOriginEvent(this)?.isTrusted ?? false;\n  }\n};\n_a = DOM_EVENT;\nfunction isDOMEvent(event) {\n  return !!event?.[DOM_EVENT];\n}\nfunction getOriginEvent(event) {\n  let trigger = event.trigger;\n  while (trigger && trigger.trigger) {\n    trigger = trigger.trigger;\n  }\n  return trigger;\n}\nfunction walkTriggerEventChain(event, callback) {\n  if (!isDOMEvent(event))\n    return;\n  let trigger = event.trigger;\n  while (trigger) {\n    const returnValue = callback(trigger);\n    if (returnValue)\n      return [trigger, returnValue];\n    trigger = trigger.trigger;\n  }\n  return;\n}\nfunction findTriggerEvent(event, type) {\n  return walkTriggerEventChain(event, (e) => e.type === type)?.[0];\n}\nfunction hasTriggerEvent(event, type) {\n  return !!findTriggerEvent(event, type);\n}\nfunction appendTriggerEvent(event, trigger) {\n  const origin = getOriginEvent(event) ?? event;\n  if (origin === trigger) {\n    throw Error(\n      \"[maverick] attemping to append event as a trigger on itself (cyclic)\" \n    );\n  }\n  if (typeof origin.trigger !== \"undefined\") {\n    console.warn(\n      `[maverick] overwriting existing trigger event: \\`${origin.trigger.type}\\` -> \\`${trigger?.type}\\`\n\n`,\n      \"Event:\\n\",\n      event,\n      \"Origin Event:\\n\",\n      origin,\n      \"Trigger Event:\\n\",\n      trigger\n    );\n  }\n  Object.defineProperty(origin, \"trigger\", {\n    configurable: true,\n    enumerable: true,\n    get: () => trigger\n  });\n}\nvar EventsTarget = class extends EventTarget {\n  addEventListener(type, callback, options) {\n    return super.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    return super.removeEventListener(type, callback, options);\n  }\n};\nfunction listenEvent(target, type, handler, options) {\n  target.addEventListener(type, handler, options);\n  return onDispose(() => target.removeEventListener(type, handler, options));\n}\nfunction isPointerEvent(event) {\n  return !!event?.type.startsWith(\"pointer\");\n}\nfunction isTouchEvent(event) {\n  return !!event?.type.startsWith(\"touch\");\n}\nfunction isMouseEvent(event) {\n  return /^(click|mouse)/.test(event?.type ?? \"\");\n}\nfunction isKeyboardEvent(event) {\n  return !!event?.type.startsWith(\"key\");\n}\nfunction wasEnterKeyPressed(event) {\n  return isKeyboardEvent(event) && event.key === \"Enter\";\n}\nfunction wasEscapeKeyPressed(event) {\n  return isKeyboardEvent(event) && event.key === \"Escape\";\n}\nfunction isKeyboardClick(event) {\n  return isKeyboardEvent(event) && (event.key === \"Enter\" || event.key === \" \");\n}\n\n// src/std/dom.ts\nfunction isDOMNode(node) {\n  return node instanceof Node;\n}\nfunction isDOMElement(node) {\n  return isDOMNode(node) && node.nodeType === 1;\n}\nfunction isDOMFragment(node) {\n  return isDOMNode(node) && node.nodeType === 11;\n}\nfunction createFragment() {\n  return document.createDocumentFragment();\n}\nfunction createComment(data) {\n  return document.createComment(data);\n}\nfunction setAttribute(host, name, value) {\n  if (!value && value !== \"\" && value !== 0) {\n    host.removeAttribute(name);\n  } else {\n    const attrValue = value + \"\";\n    if (host.getAttribute(name) !== attrValue) {\n      host.setAttribute(name, attrValue);\n    }\n  }\n}\nfunction setStyle(host, property, value) {\n  if (!value && value !== 0) {\n    host.style.removeProperty(property);\n  } else {\n    host.style.setProperty(property, value + \"\");\n  }\n}\nfunction toggleClass(host, name, value) {\n  host.classList[value ? \"add\" : \"remove\"](name);\n}\nfunction getSlottedChildren(el, name) {\n  const selector = name ? `slot[name=\"${name}\"]` : \"slot:not([name])\";\n  const slot = el.shadowRoot?.querySelector(selector);\n  const childNodes = slot?.assignedNodes({ flatten: true }) ?? [];\n  return Array.prototype.filter.call(childNodes, (node) => node.nodeType == 1);\n}\nfunction attachDeclarativeShadowDOM(element) {\n  const template = element.firstChild;\n  const mode = template.getAttribute(\"shadowroot\");\n  const shadowRoot = template.parentNode.attachShadow({ mode });\n  shadowRoot.appendChild(template.content);\n  template.remove();\n}\n\n// src/std/fn.ts\nfunction run(fn) {\n  return fn();\n}\nfunction runAll(fns, arg) {\n  for (const fn of fns)\n    fn(arg);\n}\n\n// src/std/string.ts\nfunction camelToKebabCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction camelToTitleCase(str) {\n  return uppercaseFirstChar(str.replace(/([A-Z])/g, \" $1\"));\n}\nfunction kebabToCamelCase(str) {\n  return str.replace(/-./g, (x) => x[1].toUpperCase());\n}\nfunction kebabToPascalCase(str) {\n  return kebabToTitleCase(str).replace(/\\s/g, \"\");\n}\nfunction kebabToTitleCase(str) {\n  return uppercaseFirstChar(str.replace(/-./g, (x) => \" \" + x[1].toUpperCase()));\n}\nfunction uppercaseFirstChar(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction lowercaseFirstLetter(str) {\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nvar trailingSemicolon = /;\\s*$/;\nfunction trimTrailingSemicolon(text) {\n  return text.replace(trailingSemicolon, \"\");\n}\n\n// src/std/array.ts\nfunction flattenArray(array) {\n  const flat = [];\n  for (let i = 0; i < array.length; i++) {\n    if (isArray(array[i])) {\n      flat.push(...flattenArray(array[i]));\n    } else if (array[i] || array[i] === 0) {\n      flat.push(array[i]);\n    }\n  }\n  return flat;\n}\n\nexport { DOMEvent, EventsTarget, appendTriggerEvent, attachDeclarativeShadowDOM, camelToKebabCase, camelToTitleCase, createComment, createFragment, findTriggerEvent, flattenArray, getOriginEvent, getSlottedChildren, hasTriggerEvent, isDOMElement, isDOMEvent, isDOMFragment, isDOMNode, isKeyboardClick, isKeyboardEvent, isMouseEvent, isPointerEvent, isTouchEvent, kebabToCamelCase, kebabToPascalCase, kebabToTitleCase, listenEvent, lowercaseFirstLetter, run, runAll, setAttribute, setStyle, toggleClass, trimTrailingSemicolon, uppercaseFirstChar, walkTriggerEventChain, wasEnterKeyPressed, wasEscapeKeyPressed };\n", "export { DOMEvent, EventsTarget, appendTriggerEvent, attachDeclarativeShadowDOM, camelToKebabCase, camelToTitleCase, createComment, createFragment, findTriggerEvent, flattenArray, getOriginEvent, getSlottedChildren, hasTriggerEvent, isDOMElement, isDOMEvent, isDOMFragment, isDOMNode, isKeyboardClick, isKeyboardEvent, isMouseEvent, isPointerEvent, isTouchEvent, kebabToCamelCase, kebabToPascalCase, kebabToTitleCase, listenEvent, lowercaseFirstLetter, run, runAll, setAttribute, setStyle, toggleClass, trimTrailingSemicolon, uppercaseFirstChar, walkTriggerEventChain, wasEnterKeyPressed, wasEscapeKeyPressed } from './chunks/chunk-VABDA4SA.js';\nimport { onDispose } from './chunks/chunk-NQ7TQAU7.js';\nexport { createRegex, isArray, isBoolean, isFunction, isNil, isNull, isNumber, isObject, isString, isUndefined, isWindow, noop, unwrap, unwrapDeep } from './chunks/chunk-NQ7TQAU7.js';\n\n// src/std/aria.ts\nfunction ariaBool(value) {\n  return value ? \"true\" : \"false\";\n}\n\n// src/std/disposal.ts\nfunction createDisposalBin() {\n  const disposal = /* @__PURE__ */ new Set();\n  return {\n    add(...callbacks) {\n      for (const callback of callbacks)\n        disposal.add(callback);\n    },\n    empty() {\n      for (const callback of disposal)\n        callback();\n      disposal.clear();\n    }\n  };\n}\nfunction useDisposalBin() {\n  const disposal = createDisposalBin();\n  onDispose(disposal.empty);\n  return disposal;\n}\n\n// src/std/object.ts\nfunction keysOf(obj) {\n  return Object.keys(obj);\n}\nfunction mergeProperties(...sources) {\n  const target = {};\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    if (source) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    }\n  }\n  return target;\n}\nfunction pick(source, props) {\n  const target = {};\n  for (const prop of props) {\n    Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));\n  }\n  return target;\n}\nfunction omit(source, props) {\n  return pick(\n    source,\n    keysOf(source).filter((key) => !props.includes(key))\n  );\n}\n\n// src/std/promise.ts\nfunction deferredPromise() {\n  let resolve, reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n}\nfunction timedPromise(promise, timeout, timeoutMsg) {\n  const timer = new Promise((_, reject) => {\n    const timerId = setTimeout(() => {\n      clearTimeout(timerId);\n      reject(timeoutMsg);\n    }, timeout);\n  });\n  return Promise.race([promise, timer]);\n}\n\n// src/std/timing.ts\nfunction waitTimeout(delay) {\n  return new Promise((resolve) => setTimeout(resolve, delay));\n}\nfunction waitAnimationFrame(callback) {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame((time) => {\n      callback?.(time);\n      resolve();\n    });\n  });\n}\nfunction animationFrameThrottle(func) {\n  let id = -1, lastArgs;\n  function throttle(...args) {\n    lastArgs = args;\n    if (id >= 0)\n      return;\n    id = window.requestAnimationFrame(() => {\n      func.apply(this, lastArgs);\n      id = -1;\n      lastArgs = void 0;\n    });\n  }\n  return throttle;\n}\nvar requestIdleCallback = \"requestIdleCallback\" in window ? window.requestIdleCallback : (cb) => window.requestAnimationFrame(cb);\nfunction waitIdlePeriod(callback, options) {\n  return new Promise((resolve) => {\n    requestIdleCallback((deadline) => {\n      callback?.(deadline);\n      resolve();\n    }, options);\n  });\n}\n\nexport { animationFrameThrottle, ariaBool, createDisposalBin, deferredPromise, keysOf, mergeProperties, omit, pick, timedPromise, useDisposalBin, waitAnimationFrame, waitIdlePeriod, waitTimeout };\n"],
  "mappings": "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",
  "names": ["run", "compute", "effect2", "isFunction", "_a", "effect", "_a"]
}
